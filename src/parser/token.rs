use crate::index::LabelIndex;
use crate::value::SimpleValueRef;
use super::Tag;

/// Возможные виды событий, которые могут возникнуть при чтении GFF файла. Отражают
/// появление в потоке значений из файла и структурных единиц (списков, структур, ...)
#[derive(Debug, Clone)]
pub enum Token {
  /// Событие о начале разбора GFF-читателем структуры с индексом 0 в GFF файле.
  ///
  /// Возникает после чтения заголовка файла, и позиционирования на начало первой
  /// (с индексом 0) структуры, но перед ее чтением. Следующим событием может быть:
  /// - `RootEnd`: если корневая структура не содержит полей
  /// - `StructBegin`: если первым полем корневой структуры является значение с типом `Struct`
  /// - `ListBegin`: если первым полем корневой структуры является значение с типом `List`
  /// - `Value`: если первым полем корневой структуры является значение с любым другим типом
  RootBegin {
    /// Уникальный (по задумке) идентификатор типа структуры в файле. На самом деле движок,
    /// похоже, не проверяет уникальность этих значений
    tag: Tag,
    /// Количество полей в данной структуре
    count: u32,
  },
  /// Событие об окончании разбора GFF-читателем структуры с индексом 0 в GFF файле,
  /// что сигнализирует о завершении файла.
  ///
  /// Это последнее событие при чтении файла, после него следующих событий не будет
  RootEnd,
  /// Событие о начале разбора поля в структуре. После данного события возникают события:
  /// - `StructBegin`: если полем структуры является значение с типом `Struct`
  /// - `ListBegin`: если полем структуры является значение с типом `List`
  /// - `Value`: если полем структуры является значение с любым другим типом
  Label(LabelIndex),
  /// Событие о начале разбора GFF-читателем любой структуры, кроме самой первой
  /// (для нее используется событие `RootBegin`).
  ///
  /// Возникает после позиционирования на начало любой структуры, кроме первой
  /// (с индексом 0), но перед ее чтением. Следующим событием может быть:
  /// - `StructBegin`: если первым полем структуры является значение с типом `Struct`
  /// - `ListBegin`: если первым полем структуры является значение с типом `List`
  /// - `Value`: если первым полем структуры является значение с любым другим типом
  StructBegin {
    /// Уникальный (по задумке) идентификатор типа структуры в файле. На самом деле движок,
    /// похоже, не проверяет уникальность этих значений
    tag: Tag,
    /// Количество полей в данной структуре
    count: u32,
  },
  /// Событие об окончании разбора GFF-читателем любой структуры, кроме самой первой
  /// (для нее используется событие `FileEnd`)
  StructEnd,
  /// Событие о начале разбора GFF-читателем списка объектов структуры. В параметре
  /// содержится количество записей в списке.
  ///
  /// Список всегда содержит набор структур, поэтому разбор каждой записи предваряется
  /// событием `ItemBegin` и завершается событием `ItemEnd`
  ListBegin(u32),
  /// Событие об окончании разбора GFF-читателем списка объектов
  ListEnd,
  /// Событие о начале разбора GFF-читателем любой структуры внутри списка. В отличие от
  /// обычных, такие структуры не имеют метки.
  ///
  /// Возникает после позиционирования на начало любой структуры списка.
  /// Следующим событием может быть:
  /// - `ItemEnd`: если структура списка не содержит полей
  /// - `StructBegin`: если первым полем структуры списка является поле с типом `Struct`
  /// - `ListBegin`: если первым полем структуры списка является поле с типом `List`
  /// - `Value`: если первым полем структуры списка является поле с любым другим типом
  ItemBegin {
    /// Уникальный (по задумке) идентификатор типа структуры в файле. На самом деле движок,
    /// похоже, не проверяет уникальность этих значений
    tag: Tag,
    /// Количество полей в данной структуре
    count: u32,
    /// Номер элемента в списке
    index: u32,
  },
  /// Событие об окончании разбора GFF-читателем любой структуры списка
  ItemEnd,

  /// Поле, представляющее примитивное (не имеющее структуры) значение, хранимое в файле
  Value(SimpleValueRef),
}
